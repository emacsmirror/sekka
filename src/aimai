#!/bin/sh
:; #-*- mode: nendo; syntax: scheme -*-;;
:; exec /usr/local/bin/nendo $0 $*
(require "kyotocabinet")
(require "amatch")

(define jisyo-file
  "../data/SKK-JISYO.L.201008"
  ;;"../data/SKK-JISYO.S.201001"
  )
(define cabinet-ext ".kct")
(define jarow-shikii 0.94)

(define roman->kana-table
  '(("kkya" . "っきゃ")
    ("kkyu" . "っきゅ")
    ("kkyo" . "っきょ")
    ("ggya" . "っぎゃ")
    ("ggyu" . "っぎゅ")
    ("ggyo" . "っぎょ")
    ("sshi" . "っし")
    ("ssya" . "っしゃ")
    ("ssyu" . "っしゅ")
    ("ssye" . "っしぇ")
    ("ssyo" . "っしょ")
    ("cchi" . "っち")
    ("ccha" . "っちゃ")
    ("cchu" . "っちゅ")
    ("cche" . "っちぇ")
    ("ccho" . "っちょ")
    ("ddya" . "っぢゃ")
    ("ddyu" . "っぢゅ")
    ("ddye" . "っぢぇ")
    ("ddyo" . "っぢょ")
    ("ttu" . "っつ")
    ("hhya" . "っひゃ")
    ("hhyu" . "っひゅ")
    ("hhyo" . "っひょ")
    ("bbya" . "っびゃ")
    ("bbyu" . "っびゅ")
    ("bbyo" . "っびょ")
    ("ppya" . "っぴゃ")
    ("ppyu" . "っぴゅ")
    ("ppyo" . "っぴょ")
    ("rrya" . "っりゃ")
    ("rryu" . "っりゅ")
    ("rryo" . "っりょ")
    ("ddyi" . "っでぃ")
    ("ddhi" . "っでぃ")
    ("xtu" . "っ")
    ("ttya" . "っちゃ")
    ("ttyi" . "っち")
    ("ttyu" . "っちゅ")
    ("ttye" . "っちぇ")
    ("ttyo" . "っちょ")
    ("kya" . "きゃ")
    ("kyu" . "きゅ")
    ("kyo" . "きょ")
    ("gya" . "ぎゃ")
    ("gyu" . "ぎゅ")
    ("gyo" . "ぎょ")
    ("shi" . "し")
    ("chi" . "ち")
    ("cha" . "ちゃ")
    ("chu" . "ちゅ")
    ("che" . "ちぇ")
    ("cho" . "ちょ")
    ("dya" . "ぢゃ")
    ("dyu" . "ぢゅ")
    ("dye" . "ぢぇ")
    ("dyo" . "ぢょ")
    ("vvu" . "っう゛")
    ("vva" . "っう゛ぁ")
    ("vvi" . "っう゛ぃ")
    ("vve" . "っう゛ぇ")
    ("vvo" . "っう゛ぉ")
    ("kka" . "っか")
    ("gga" . "っが")
    ("kki" . "っき")
    ("ggi" . "っぎ")
    ("kku" . "っく")
    ("ggu" . "っぐ")
    ("kke" . "っけ")
    ("gge" . "っげ")
    ("kko" . "っこ")
    ("ggo" . "っご")
    ("ssa" . "っさ")
    ("zza" . "っざ")
    ("jji" . "っじ")
    ("jja" . "っじゃ")
    ("jju" . "っじゅ")
    ("jje" . "っじぇ")
    ("jjo" . "っじょ")
    ("ssu" . "っす")
    ("zzu" . "っず")
    ("sse" . "っせ")
    ("zze" . "っぜ")
    ("sso" . "っそ")
    ("zzo" . "っぞ")
    ("tta" . "った")
    ("dda" . "っだ")
    ("ddi" . "っぢ")
    ("ddu" . "っづ")
    ("tte" . "って")
    ("dde" . "っで")
    ("tto" . "っと")
    ("ddo" . "っど")
    ("hha" . "っは")
    ("bba" . "っば")
    ("ppa" . "っぱ")
    ("hhi" . "っひ")
    ("bbi" . "っび")
    ("ppi" . "っぴ")
    ("ffu" . "っふ")
    ("ffa" . "っふぁ")
    ("ffi" . "っふぃ")
    ("ffe" . "っふぇ")
    ("ffo" . "っふぉ")
    ("bbu" . "っぶ")
    ("ppu" . "っぷ")
    ("hhe" . "っへ")
    ("bbe" . "っべ")
    ("ppe" . "っぺ")
    ("hho" . "っほ")
    ("bbo" . "っぼ")
    ("ppo" . "っぽ")
    ("yya" . "っや")
    ("yyu" . "っゆ")
    ("yyo" . "っよ")
    ("rra" . "っら")
    ("rri" . "っり")
    ("rru" . "っる")
    ("rre" . "っれ")
    ("rro" . "っろ")
    ("tu" . "つ")
    ("nya" . "にゃ")
    ("nyu" . "にゅ")
    ("nyo" . "にょ")
    ("hya" . "ひゃ")
    ("hyu" . "ひゅ")
    ("hyo" . "ひょ")
    ("bya" . "びゃ")
    ("byu" . "びゅ")
    ("byo" . "びょ")
    ("pya" . "ぴゃ")
    ("pyu" . "ぴゅ")
    ("pyo" . "ぴょ")
    ("mya" . "みゃ")
    ("myu" . "みゅ")
    ("myo" . "みょ")
    ("xya" . "ゃ")
    ("xyu" . "ゅ")
    ("xyo" . "ょ")
    ("rya" . "りゃ")
    ("ryu" . "りゅ")
    ("ryo" . "りょ")
    ("xwa" . "ゎ")
    ("thi" . "てぃ")
    ("hhu" . "っふ")
    ("shu" . "しゅ")
    ("chu" . "ちゅ")
    ("sya" . "しゃ")
    ("syu" . "しゅ")
    ("sye" . "しぇ")
    ("syo" . "しょ")
    ("jya" . "じゃ")
    ("jyu" . "じゅ")
    ("jye" . "じぇ")
    ("jyo" . "じょ")
    ("tya" . "ちゃ")
    ("tyi" . "ち")
    ("tyu" . "ちゅ")
    ("tye" . "ちぇ")
    ("tyo" . "ちょ")
    ("dhi" . "でぃ")
    ("xtu" . "っ")
    ("xa" . "ぁ")
    ("xi" . "ぃ")
    ("xu" . "ぅ")
    ("vu" . "う゛")
    ("va" . "う゛ぁ")
    ("vi" . "う゛ぃ")
    ("ve" . "う゛ぇ")
    ("vo" . "う゛ぉ")
    ("xe" . "ぇ")
    ("xo" . "ぉ")
    ("ka" . "か")
    ("ga" . "が")
    ("ki" . "き")
    ("gi" . "ぎ")
    ("ku" . "く")
    ("gu" . "ぐ")
    ("ke" . "け")
    ("ge" . "げ")
    ("ko" . "こ")
    ("go" . "ご")
    ("sa" . "さ")
    ("za" . "ざ")
    ("ji" . "じ")
    ("su" . "す")
    ("zu" . "ず")
    ("se" . "せ")
    ("ze" . "ぜ")
    ("so" . "そ")
    ("zo" . "ぞ")
    ("ta" . "た")
    ("da" . "だ")
    ("di" . "ぢ")
    ("tt" . "っ")
    ("du" . "づ")
    ("te" . "て")
    ("de" . "で")
    ("to" . "と")
    ("do" . "ど")
    ("na" . "な")
    ("ni" . "に")
    ("nu" . "ぬ")
    ("ne" . "ね")
    ("no" . "の")
    ("ha" . "は")
    ("ba" . "ば")
    ("pa" . "ぱ")
    ("hi" . "ひ")
    ("bi" . "び")
    ("pi" . "ぴ")
    ("fu" . "ふ")
    ("fa" . "ふぁ")
    ("fi" . "ふぃ")
    ("fe" . "ふぇ")
    ("fo" . "ふぉ")
    ("bu" . "ぶ")
    ("pu" . "ぷ")
    ("he" . "へ")
    ("be" . "べ")
    ("pe" . "ぺ")
    ("ho" . "ほ")
    ("bo" . "ぼ")
    ("po" . "ぽ")
    ("ma" . "ま")
    ("mi" . "み")
    ("mu" . "む")
    ("me" . "め")
    ("mo" . "も")
    ("ya" . "や")
    ("yu" . "ゆ")
    ("yo" . "よ")
    ("ra" . "ら")
    ("ri" . "り")
    ("ru" . "る")
    ("re" . "れ")
    ("ro" . "ろ")
    ("wa" . "わ")
    ("wi" . "ゐ")
    ("we" . "ゑ")
    ("wo" . "を")
    ("n" . "ん")
    ("a" . "あ")
    ("i" . "い")
    ("u" . "う")
    ("e" . "え")
    ("o" . "お")
    ("-" . "ー")
    ("^" . "ー")))


(define kana->roman-hash 
  (let1 h (make-hash-table)
    (map
     (lambda (x)
       (let ((k (cdr x))
             (v (car x)))
         (hash-table-put! h k v)))
     (reverse roman->kana-table))
    h))


(define (kana->roman str)
  (let ((lst '())
        (h kana->roman-hash))
    (let loop ((str str))
      (let ((str1 (str.slice 0 1))
            (str2 (str.slice 0 2))
            (str3 (str.slice 0 3)))
        (cond
         ((eq? 0 (str.size))
          #f)
         ((hash-table-exist? h str3)
          (set! lst (cons (hash-table-get h str3) lst))
          (loop (str.slice (str3.size) (str.size))))
         ((hash-table-exist? h str2)
          (set! lst (cons (hash-table-get h str2) lst))
          (loop (str.slice (str2.size) (str.size))))
         ((hash-table-exist? h str1)
          (set! lst (cons (hash-table-get h str1) lst))
          (loop (str.slice (str1.size) (str.size)))))))
    (string-join (reverse lst))))

    
(define (init-db name)
  (if (KyotoCabinet::DB.process
       (+ name cabinet-ext)
       (&block (db)
         (begin
           (with-open name
                      (lambda (f)
                        (for-each
                         (lambda (line)
                           (cond
                            ((rxmatch #/^([あ-ん]+)[ ][\/](.+)[\/]$/ (line.chomp))
                             => (lambda (m)
                                  (let ((k (kana->roman (rxmatch-substring m 1)))
                                        (v (rxmatch-substring m 2)))
                                    (hash-table-put! db k v))))
                            ((rxmatch #/^([a-zA-Z]+)[ ][\/](.+)[\/]$/ (line.chomp))
                             => (lambda (m)
                                  (let ((k (rxmatch-substring m 1))
                                        (v (rxmatch-substring m 2)))
                                    (hash-table-put! db k v))))))
                         (f.readlines.to_list)))))))
      (printf "open error: %s\n" db.error)))


(define (leven str1 str2)
  (. (Amatch::Levenshtein.new str1) match str2))

(define (jaro str1 str2)
  (. (Amatch::Jaro.new str1) match str2))

(define (jarow str1 str2)
  (. (Amatch::JaroWinkler.new str1) match str2))

(define (paird str1 str2)
  (. (Amatch::PairDistance.new str1) match str2))


;; return unsorted list
;;  '(
;;     ( distance key val )
;;         .
;;         .
;;         .
;;   )
(define (aimai-search name keyword)
  (let ((db (KyotoCabinet::DB.new))
        (k0 (keyword.slice 0 1)))
    (if (not (db.open (+ name cabinet-ext)))
        (printf "open error: %s\n" db.error)
        (let1 result '()
          (db.each
           (&block (k v)
             (when (eq? k0 (k.slice 0 1))
               (let (
                     (_jarow (jarow keyword k))
                     (_jaro  (jaro  keyword k))
                     (_leven (leven keyword k))
                     (_paird (paird keyword k)))
                 (when (< jarow-shikii _jarow)
                   (set! result (cons
                                 (list
                                  _jarow _jaro _leven _paird
                                  k v)
                                 result)))))))
          (db.close)
          result))))


(define (disp-search-result result)
  (printf "閾値 = %f\n" jarow-shikii)
  (print "----------")
  (for-each
   (lambda (x)
     (let1 vec (x.to_arr)
       (printf " JaroW(%1.5f) Jaro(%1.5f) Leven(%1.5f) PairD(%1.5f) [%s]:[%s]\n"
               (vector-ref vec 0)
               (vector-ref vec 1)
               (vector-ref vec 2)
               (vector-ref vec 3)
               (vector-ref vec 4)
               (vector-ref vec 5))))
   (sort-by result
            (lambda (item)
              (- 1.0 (car item))))))
  
(define (main argv)
  (define (readline)
    (printf "> ")
    (STDIN.readline.chomp))
  (cond
   ((eq? 0 (length argv))
    (let loop ((line (readline)))
      (if (rxmatch #/^[qQ]$/ line)
          (printf "quit.\n")
          (begin
            (disp-search-result
             (aimai-search jisyo-file line))
            (loop (readline))))))
   (else
    (init-db jisyo-file))))

