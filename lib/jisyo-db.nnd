:; #-*- mode: nendo; syntax: scheme -*-;;

(use srfi-1)
(require "./lib/kvs")
(load "./lib/util.nnd")

(define alphabet-string "abcdefghijklmnopqrstuvwxyz>")
(define alphabet-lower-list (to-list (alphabet-string.split "")))
(define alphabet-upper-list (to-list (alphabet-string.upcase.split "")))
(define alphabet-pairs (append-map
                        (lambda (a)
                          (map
                           (lambda (b)
                             (+ a b))
                           (append alphabet-upper-list alphabet-lower-list)))
                        alphabet-lower-list))

;; KVS type setting
(define *kvs-type* 'kyotocabinet)  ;; default
(define (set-kvs-type type)
  (if (not (symbol? type))
      (error "Error: set-kvs-type requires symbol argument.")
      (set! *kvs-type* type)))
(define (get-kvs-type)
  *kvs-type*)


(define (create-2char-hash kvs keylist)
  (let ((okuri-ari-hash   (make-hash-table))
        (okuri-nashi-hash (make-hash-table)))
    (for-each
     (lambda (k)
       (when (rxmatch #/^[a-zA-Z^>-]+$/ k)
         (let1 sliced (k.slice 0 2)
           (when (= 2 sliced.size)
             (if (rxmatch #/[A-Z]$/ k)
                 (hash-table-push! okuri-ari-hash   sliced k)
                 (hash-table-push! okuri-nashi-hash sliced k))))))
     keylist)
    (values okuri-ari-hash
            okuri-nashi-hash)))

(define (setup-ready-made-keylist kvs keylist)
  (for-each
   (lambda (key)
     (unless (kvs.get key #f)
       (kvs.put! key "")))
   alphabet-pairs)
  
  (receive (okuri-ari-hash
            okuri-nashi-hash)
      (create-2char-hash kvs keylist)

    ;; OKURI-ARI
    (for-each
     (lambda (key)
       (kvs.put! (+ "(" key.upcase ")")
                 (string-join (delete-duplicates (hash-table-get okuri-ari-hash key)) " ")))
     (hash-table-keys okuri-ari-hash))

    ;; OKURI-NASHI
    (for-each
     (lambda (key)
       (kvs.put! (+ "(" key.downcase ")")
                 (string-join (delete-duplicates (hash-table-get okuri-nashi-hash key)) " ")))
     (hash-table-keys okuri-nashi-hash))))


(define (load-sekka-jisyo-f f filename)
  (let1 kvs (Kvs.new *kvs-type*)
    (kvs.open filename)
    (kvs.clear)
    (let1 keylist '()
      (for-each
       (lambda (line)
         (let1 fields (to-list (line.split " "))
           (set! keylist (cons (first fields) keylist))
           (kvs.put!
            (first fields)
            (if-let1 curval (kvs.get (first fields) #f)
              (+ curval "/" (if-let1 m (rxmatch #/^[C\/](.+)$/ (second fields))
                              (rxmatch-substring m 1)
                              (second fields)))
              (second fields)))))
       (f.readlines.to_list))
      (setup-ready-made-keylist kvs keylist))
    (kvs.close)))


(define (dump-sekka-jisyo-f f filename)
  (let1 kvs (Kvs.new *kvs-type*)
    (kvs.open filename)
    (for-each
     (lambda (key)
       (f.puts (+ key " " (kvs.get key))))
     (to-list (kvs.keys)))
    (kvs.close)))


(define (openSekkaJisyo filename)
  (let1 kvs (Kvs.new *kvs-type*)
    (kvs.open filename)
    kvs))

;; Export to Ruby world
(export-to-ruby openSekkaJisyo)
