:; #-*- mode: nendo; syntax: scheme -*-;;

(use srfi-1)

;; このテーブルはruby-romkan から変換し、一部不足を追加した。
;;  クンレイ、日本式、ヘボン式もデータ中に併記し全てを網羅している。
(define sekka-kana->roman-alist
  '(
    ("ぁ"        "xa" "la")
    ("あ"        "a")
    ("ぃ"        "xi" "li")
    ("い"        "i")
    ("ぅ"        "xu" "lu")
    ("う"        "u")
    ("う゛"      "vu")
    ("う゛ぁ"    "va")
    ("う゛ぃ"    "vi")
    ("う゛ぇ"    "ve")
    ("う゛ぉ"    "vo")
    ("ぇ"        "xe" "le")
    ("え"        "e")
    ("ぉ"        "xo" "lo")
    ("お"        "o")
    ("か"        "ka" "ca")
    ("が"        "ga")
    ("き"        "ki" "ci")
    ("きゃ"      "kya")
    ("きゅ"      "kyu")
    ("きょ"      "kyo")
    ("ぎ"        "gi")
    ("ぎゃ"      "gya")
    ("ぎゅ"      "gyu")
    ("ぎょ"      "gyo")
    ("く"        "ku" "cu")
    ("ぐ"        "gu")
    ("け"        "ke" "ce")
    ("げ"        "ge")
    ("こ"        "ko" "co")
    ("ご"        "go")
    ("さ"        "sa")
    ("ざ"        "za")
    ("し"        "shi" "si")
    ("しゃ"      "sha" "sya")
    ("しゅ"      "shu" "syu") ;; hu の例外処理: shu は sfu になってはいけない
    ("しぇ"      "she" "sye")
    ("しょ"      "sho" "syo")
     ("じ"        "ji" "zi")
     ("じゃ"      "ja" "jya")
     ("じゅ"      "ju" "jyu")
     ("じぇ"      "je" "jye")
     ("じょ"      "jo" "jyo")
     ("す"        "su")
     ("ず"        "zu")
     ("せ"        "se")
     ("ぜ"        "ze")
     ("そ"        "so")
     ("ぞ"        "zo")
     ("た"        "ta")
     ("だ"        "da")
     ("ち"        "chi" "ti" "tyi")
     ("ちゃ"      "cha" "tya")
     ("ちゅ"      "chu" "tyu") ;; hu の例外処理: chu は cfu になってはいけない
     ("ちぇ"      "che" "tye")
     ("ちょ"      "cho" "tyo")
     ("ぢ"        "di")
     ("ぢゃ"      "dya")
     ("ぢゅ"      "dyu")
     ("ぢぇ"      "dye")
     ("ぢょ"      "dyo")
     ("っ"        "tt" "xtu" "xtsu")
     ("っう゛"    "vvu")
     ("っう゛ぁ"  "vva")
     ("っう゛ぃ"  "vvi")
     ("っう゛ぇ"  "vve")
     ("っう゛ぉ"  "vvo")
     ("っか"      "kka")
     ("っが"      "gga")
     ("っき"      "kki")
     ("っきゃ"    "kkya")
     ("っきゅ"    "kkyu")
     ("っきょ"    "kkyo")
     ("っぎ"      "ggi")
     ("っぎゃ"    "ggya")
     ("っぎゅ"    "ggyu")
     ("っぎょ"    "ggyo")
     ("っく"      "kku")
     ("っぐ"      "ggu")
     ("っけ"      "kke")
     ("っげ"      "gge")
     ("っこ"      "kko")
     ("っご"      "ggo")
     ("っさ"      "ssa")
     ("っざ"      "zza")
     ("っし"      "sshi")
     ("っしゃ"    "ssha")
     ("っしゅ"    "sshu")
     ("っしぇ"    "sshe")
     ("っしょ"    "ssho")
     ("っじ"      "jji")
     ("っじゃ"    "jja")
     ("っじゅ"    "jju")
     ("っじぇ"    "jje")
     ("っじょ"    "jjo")
     ("っす"      "ssu")
     ("っず"      "zzu")
     ("っせ"      "sse")
     ("っぜ"      "zze")
     ("っそ"      "sso")
     ("っぞ"      "zzo")
     ("った"      "tta")
     ("っだ"      "dda")
     ("っち"      "cchi" "ttyi")
     ("っちゃ"    "ccha" "ttya")
     ("っちゅ"    "cchu" "ttyu")
     ("っちぇ"    "cche" "ttye")
     ("っちょ"    "ccho" "ttyo")
     ("っぢ"      "ddi")
     ("っぢゃ"    "ddya")
     ("っぢゅ"    "ddyu")
     ("っぢぇ"    "ddye")
     ("っぢょ"    "ddyo")
     ("っつ"      "ttsu")
     ("っづ"      "ddu")
     ("って"      "tte")
     ("っで"      "dde")
     ("っと"      "tto")
     ("っど"      "ddo")
     ("っは"      "hha")
     ("っば"      "bba")
     ("っぱ"      "ppa")
     ("っひ"      "hhi")
     ("っひゃ"    "hhya")
     ("っひゅ"    "hhyu")
     ("っひょ"    "hhyo")
     ("っび"      "bbi")
     ("っびゃ"    "bbya")
     ("っびゅ"    "bbyu")
     ("っびょ"    "bbyo")
     ("っぴ"      "ppi")
     ("っぴゃ"    "ppya")
     ("っぴゅ"    "ppyu")
     ("っぴょ"    "ppyo")
     ("っふ"      "ffu" "hhu")
     ("っふぁ"    "ffa")
     ("っふぃ"    "ffi")
     ("っふぇ"    "ffe")
     ("っふぉ"    "ffo")
     ("っぶ"      "bbu")
     ("っぷ"      "ppu")
     ("っへ"      "hhe")
     ("っべ"      "bbe")
     ("っぺ"      "ppe")
     ("っほ"      "hho")
     ("っぼ"      "bbo")
     ("っぽ"      "ppo")
     ("っや"      "yya")
     ("っゆ"      "yyu")
     ("っよ"      "yyo")
     ("っら"      "rra")
     ("っり"      "rri")
     ("っりゃ"    "rrya")
     ("っりゅ"    "rryu")
     ("っりょ"    "rryo")
     ("っる"      "rru")
     ("っれ"      "rre")
     ("っろ"      "rro")
     ("つ"        "tsu" "tu")
     ("づ"        "du")
     ("て"        "te")
     ("で"        "de")
     ("と"        "to")
     ("ど"        "do")
     ("な"        "na")
     ("に"        "ni")
     ("にゃ"      "nya")
     ("にゅ"      "nyu")
     ("にょ"      "nyo")
     ("ぬ"        "nu")
     ("ね"        "ne")
     ("の"        "no")
     ("は"        "ha")
     ("ば"        "ba")
     ("ぱ"        "pa")
     ("ひ"        "hi")
     ("ひゃ"      "hya")
     ("ひゅ"      "hyu")
     ("ひょ"      "hyo")
     ("び"        "bi")
     ("びゃ"      "bya")
     ("びゅ"      "byu")
     ("びょ"      "byo")
     ("ぴ"        "pi")
     ("ぴゃ"      "pya")
     ("ぴゅ"      "pyu")
     ("ぴょ"      "pyo")
     ("ふ"        "fu" "hu")
     ("ふぁ"      "fa")
     ("ふぃ"      "fi")
     ("ふぇ"      "fe")
     ("ふぉ"      "fo")
     ("ぶ"        "bu")
     ("ぷ"        "pu")
     ("へ"        "he")
     ("べ"        "be")
     ("ぺ"        "pe")
     ("ほ"        "ho")
     ("ぼ"        "bo")
     ("ぽ"        "po")
     ("ま"        "ma")
     ("み"        "mi")
     ("みゃ"      "mya")
     ("みゅ"      "myu")
     ("みょ"      "myo")
     ("む"        "mu")
     ("め"        "me")
     ("も"        "mo")
     ("ゃ"        "xya")
     ("や"        "ya")
     ("ゅ"        "xyu")
     ("ゆ"        "yu")
     ("ょ"        "xyo")
     ("よ"        "yo")
     ("ら"        "ra")
     ("り"        "ri")
     ("りゃ"      "rya")
     ("りゅ"      "ryu")
     ("りょ"      "ryo")
     ("る"        "ru")
     ("れ"        "re")
     ("ろ"        "ro")
     ("ゎ"        "xwa")
     ("わ"        "wa")
     ("ゐ"        "wi")
     ("ゑ"        "we")
     ("を"        "wo")
     ("ん"        "n")
     ("でぃ"      "dyi" "dhi")
     ("っでぃ"    "ddyi" "ddhi")
     ("ー"        "-" "^")

     ;; Ruby romkanからの不足分追加
     ("てぃ"     "thi")
     ;; Sekkaの辞書に入っている特別なキーワード ">あん" など

     (">"        ">")))


;; ハッシュテーブル  平仮名   =>ローマ字
(define sekka-kana->roman-hash (alist->hash-table sekka-kana->roman-alist))

;; ハッシュテーブル  ローマ字 =>平仮名
(define sekka-roman->kana-hash
  (let1 swapped
      (append-map
       (lambda (x)
         (let ((hira   (car x))
               (romans (cdr x)))
           (map (lambda (r) (list r hira)) romans)))
       sekka-kana->roman-alist)
    (alist->hash-table swapped)))


;;(define %match-and-push
;;  (marco (str)
;;         ))

(define (gen-hiragana->roman-pattens hiragana)
  (let ((lst '())
        (h sekka-kana->roman-hash))
    (let loop ((str hiragana))
      (let ((str1 (str.slice 0 1))
            (str2 (str.slice 0 2))
            (str3 (str.slice 0 3)))
        (cond
         ((eq? 0 (str.size))
          #f)
         ((hash-table-exist? h str3)
          (set! lst (cons (hash-table-get h str3) lst))
          (loop (str.slice (str3.size) (str.size))))
         ((hash-table-exist? h str2)
          (set! lst (cons (hash-table-get h str2) lst))
          (loop (str.slice (str2.size) (str.size))))
         ((hash-table-exist? h str1)
          (set! lst (cons (hash-table-get h str1) lst))
          (loop (str.slice (str1.size) (str.size)))))))
    (reverse lst)))


(define (gen-roman->hiragana roman-str)
  (let ((lst '())
        (h sekka-roman->kana-hash))
    (let loop ((str roman-str))
      (let ((str1 (str.slice 0 1))
            (str2 (str.slice 0 2))
            (str3 (str.slice 0 3))
            (str4 (str.slice 0 4)))
        (cond
         ((eq? 0 (str.size))
          #f)
         ((hash-table-exist? h str4)
          (set! lst (cons (hash-table-get h str4) lst))
          (loop (str.slice (str4.size) (str.size))))
         ((hash-table-exist? h str3)
          (set! lst (cons (hash-table-get h str3) lst))
          (loop (str.slice (str3.size) (str.size))))
         ((hash-table-exist? h str2)
          (set! lst (cons (hash-table-get h str2) lst))
          (loop (str.slice (str2.size) (str.size))))
         ((hash-table-exist? h str1)
          (set! lst (cons (hash-table-get h str1) lst))
          (loop (str.slice (str1.size) (str.size)))))))
    (string-join
     (map
      (lambda (x) (car x))
      (reverse lst)))))


;; This function port from Gauche-0.9's util.combinations.
(define (cartesian-product lol)
  (if (null? lol)
      (list '())
      (let ((l (car lol))
            (rest (cartesian-product (cdr lol))))
        (append-map
         (lambda (x)
           (map (lambda (sub-prod) (cons x sub-prod)) rest))
         l))))


(define (patterns->roman-list patterns)
  (map
   (lambda (x)
     (string-join x))
   (cartesian-product patterns)))
  

(define (gen-hiragana->roman-list hiragana)
  (patterns->roman-list 
   (gen-hiragana->roman-pattens hiragana)))
