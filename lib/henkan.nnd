:; #-*- mode: nendo; syntax: scheme -*-;;
;;
;;      石火変換ライブラリ
;;
(use srfi-1)
(require "amatch")
(load "./lib/util.nnd")
(load "./lib/roman-lib.nnd")
(require "./lib/approximatesearch")

;; 曖昧検索
;;  リストで返す。 (ソート済み検索結果)
(define (approximate-search kvs keyword okuri-ari-flag)
  (define jarow-shikii 0.94)
  (let* ((a-search (ApproximateSearch.new jarow-shikii))
         (lst      (append-map
                    (lambda (x)
                      (let* ((val (vector-ref x 0))
                             (k   (vector-ref x 1))
                             (v   (kvs.get k ""))
                             (v-pair (string-split-first-and-rest v))
                             (v-first (car v-pair))
                             (v-rest  (cdr v-pair)))
                        (map
                         (lambda (element)
                           (list val k (+ v-first element)))
                         (to-list (v-rest.split "/")))))
                    (to-list (a-search.search kvs keyword okuri-ari-flag))))
         (sorted-lst  (sort-by lst (lambda (item) (- 1.0 (car item))))))
    sorted-lst))


;; 厳密検索
(define (exact-search kvs keyword)
  (let1 v (kvs.get keyword #f)
    (if v
        `((1.0 ,keyword ,v))
        '())))


;; split "/a;annotation/b/c/" into `(("a" "annotation" ,src) ("b" #f ,src) ("c" #f ,src))  alist
(define (split-henkan-kouho str src . okuri)
  (let* ((trimmed (cond
                   ((rxmatch #/^[\/](.+)$/ str)
                    => (lambda (m)
                         (rxmatch-substring m 1)))
                   (else
                    "")))
         (splitted (filter
                    (lambda (str) (< 0 str.size))
                    (to-list (trimmed.split "/"))))
         (okuri    (get-optional okuri "")))
    ;; pickup annotation
    (map
     (lambda (entry)
       (let1 vec (entry.split ";")
         (list (+ (vector-ref vec 0) okuri)
               (vector-ref vec 1 #f)
               src)))
     splitted)))


;; 送り仮名なしの変換
(define (henkan-okuri-nashi kvs keyword)
  (let* ((result (approximate-search kvs keyword #f))
         (kouho  (uniq (map
                        (lambda (x)
                          (third x))
                        result))))
    (append-map
     (lambda (value)
       (if-let1 m (rxmatch #/^C(.+)$/ value)
         (split-henkan-kouho
          (kvs.get (string-drop value 1))
          (rxmatch-substring m 1)
          ) ;; continue to fetch
         (split-henkan-kouho
          value
          keyword)))
     kouho)))


;; 送り仮名ありの変換
(define (henkan-okuri-ari kvs keyword)
  (let* ((keyword  (let1 _pair (string-split-first-and-rest keyword)
                     (+ (. (car _pair) downcase)
                        (cdr _pair))))
         (m        (rxmatch #/^([a-z])([a-z\-^]*)([A-Z])([a-zA-Z]*)$/ keyword)))
    (if (not m)
        '() ;; 変換候補無し
        (let* ((result (approximate-search kvs
                                           (+ (rxmatch-substring m 1)
                                              (rxmatch-substring m 2)
                                              (rxmatch-substring m 3))
                                           #t))
               (okurigana  (gen-roman->hiragana (. (+
                                                    (rxmatch-substring m 3)
                                                    (rxmatch-substring m 4)) downcase)))
               (kouho      (uniq (map
                                  (lambda (x)
                                    (third x))
                                  result))))
          (append-map
           (lambda (value)
             (if-let1 m (rxmatch #/^C(.+)$/ value)
               (split-henkan-kouho
                (kvs.get (string-drop value 1))
                (rxmatch-substring m 1)
                okurigana) ;; continue to fetch
               (split-henkan-kouho value keyword okurigana)))
           kouho)))))


;; 平仮名の変換
(define (henkan-hiragana kvs keyword)
  (let* ((str  (keyword.downcase))
         (hira (gen-roman->hiragana str))
         (kata (gen-roman->katakana str)))
    (if hira
        `(
          ( ,hira #f ,keyword)
          ( ,kata #f ,keyword))
        `((,keyword #f ,keyword)))))


;; 記号を含むキーワードの変換
(define (henkan-non-kanji kvs keyword)
  (let* ((result (exact-search kvs keyword))
         (kouho  (map
                  (lambda (x)
                    (third x))
                  result)))
    (append-map
     (lambda (value)
       (split-henkan-kouho value keyword))
     kouho)))


;; keyword には ローマ字のみを受け付ける
(define (sekka-henkan kvs keyword)
  ;; キーワードの種別で処理を分割する
  (cond
   ((rxmatch #/[A-Z]/ keyword)
    (let1 keyword (string-downcase-first keyword)
      (cond
       ((rxmatch #/[a-z][A-Z]/ keyword)
        ;; 送りあり
        ;;(let1 result (approximate-search db keyword #t)  (disp-search-result result))
        (henkan-okuri-ari kvs keyword))
       (else
        ;; 送りなし
        ;;(let1 result (approximate-search db keyword #f)  (disp-search-result result))
        (henkan-okuri-nashi kvs keyword)))))
   ((gen-roman->hiragana keyword)
    (append
     (henkan-hiragana kvs keyword)
     (henkan-okuri-nashi kvs keyword)))
   (else
    (henkan-non-kanji kvs keyword))))


;; conversion #f => nil for EmacsLisp
(define (sekkaHenkan kvs cachesv keyword)
  (let1 keyword (keyword.strip)
    (if-let1 fetched (and cachesv
                          (cachesv.get keyword #f))
      (begin
        keyword
        (read-from-string fetched))
      (let1 henkan-result (map
                           (lambda (x)
                             (map (lambda (val) (if val val nil)) x))
                           (sekka-henkan kvs keyword))
        (and cachesv
             (not (null? henkan-result))
             (cachesv.put! keyword (write-to-string henkan-result)))
        henkan-result))))
;; Export to Ruby world
(export-to-ruby sekkaHenkan)


;; 確定処理: 最終確定語を変換候補の先頭に持ってくる。
;;  key   ... "developer" や "へんかん" など、変換候補レコードのキーとなる文字列
;;  tango ... "変換" など、変換候補から最終確定した、変換候補の文字列
;;  登録失敗したら nil を返す
(define (sekkaKakutei kvs cachesv key tango)
  (define (fetch kvs key)
    (kvs.get key #f))

  (define (overwrite kvs key value)
    (kvs.put! key value))

  (define (join-henkan-kouho lst)
    (+ "/"
       (string-join
        (map
         (lambda (x)
           (if (second x)
               (+ (first x) ";" (second x))
               (first x)))
         lst)
        "/")
       "/"))

  (if-let1 kouho-str (fetch kvs key)
    (if (rxmatch #/^\// kouho-str)
        (let* ((kouho-lst (split-henkan-kouho kouho-str key))
               (no1
                (filter (lambda (x)
                          (eq? (car x) tango))
                        kouho-lst))
               (other
                (filter (lambda (x)
                          (not (eq? (car x) tango)))
                        kouho-lst)))
          (overwrite kvs key
                     (join-henkan-kouho (append no1 other)))
          tango)
        nil)
    nil))
;; Export to Ruby world
(export-to-ruby sekkaKakutei)
