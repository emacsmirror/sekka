:; #-*- mode: nendo; syntax: scheme -*-;;
;;
;;      石火変換ライブラリ
;;
(use srfi-1)
(require "kyotocabinet")
(require "amatch")
(load "./lib/roman-lib.nnd")
(require "./lib/approximatesearch")

(define (string-drop str n)
  (or (str.slice n (str.size))
      ""))

;; 曖昧検索
;;  リストで返す。 (ソート済み検索結果)
(define (approximate-search db keyword okuri-ari-flag)
  (define jarow-shikii 0.94)
  (let* ((a-search (ApproximateSearch.new jarow-shikii))
         (lst      (map
                    (lambda (x)
                      (let* ((val (vector-ref x 0))
                             (k   (vector-ref x 1))
                             (v   (hash-table-get db k)))
                        (list val k v)))
                    (to-list (a-search.search db keyword okuri-ari-flag))))
         (sorted-lst  (sort-by lst (lambda (item) (- 1.0 (car item))))))
    sorted-lst))


;; split "/a;annotation/b/c/" into '(("a" . "annotation") ("b" . #f) ("c" . #f))  alist
(define (split-henkan-kouho str . okuri)
  (let* ((trimmed (cond
                   ((rxmatch #/^[\/](.+)[\/]?$/ str)
                    => (lambda (m)
                         (rxmatch-substring m 1)))
                   (else
                    (errorf "split-henkan-kouho got [%s]. it requires /a/b/c/ format string" str))))
         (splitted (to-list (trimmed.split "/")))
         (okuri    (get-optional okuri "")))
    ;; pickup annotation
    (map
     (lambda (entry)
       (let1 vec (entry.split ";")
         (cons (+ (vector-ref vec 0) okuri)
               (vector-ref vec 1 #f))))
     splitted)))


;; 送り仮名なしの変換
(define (henkan-okuri-nashi db keyword)
  (let* ((result (approximate-search db keyword #f))
         (kouho  (uniq (map
                        (lambda (x)
                          (third x))
                        result))))
    (append-map
     (lambda (value)
       (split-henkan-kouho
        (if (rxmatch #/^C/ value)
            (hash-table-get db (string-drop value 1)) ;; continue
            value)))
     kouho)))


;; 送り仮名ありの変換
(define (henkan-okuri-ari db keyword)
  (let1 m (rxmatch #/^([a-zA-Z])([a-z\-^]+)([A-Z])([a-zA-Z]*)$/ keyword)
    (if (not m)
        (errorf "henkan-okuri-ari: requires xxxxXx or XxxxxXx ascii format.  got:[%s] " keyword)
        (let* ((result (approximate-search db
                                           (+ (. (rxmatch-substring m 1) downcase)
                                              (rxmatch-substring m 2)
                                              (rxmatch-substring m 3))
                                           #t))
               (okurigana  (gen-roman->hiragana (. (+
                                                    (rxmatch-substring m 3)
                                                    (rxmatch-substring m 4)) downcase)))
               (kouho      (uniq (map
                                  (lambda (x)
                                    (third x))
                                  result))))
          (append-map
           (lambda (value)
             (split-henkan-kouho
              (if (rxmatch #/^C/ value)
                  (hash-table-get db (string-drop value 1)) ;; continue
                  value)
              okurigana))
           kouho)))))


;; 平仮名の変換
(define (henkan-hiragana db keyword)
  (let1 str (keyword.downcase)
    `(
      ( ,(gen-roman->hiragana str) . #f )
      ( ,(gen-roman->katakana str) . #f ))))


;; 記号混じりの文字列の変換
(define (henkan-non-kanji db keyword)
  `(("(未サポート)" . #f)))


;; keyword には ローマ字のみを受け付ける
(define (sekka-henkan db keyword)
  ;; キーワードの種別で処理を分割する
  (cond
   ((rxmatch #/[A-Z]/ keyword)
    (cond
     ((rxmatch #/[A-Z]/ (keyword.slice 1 keyword.size))
      ;; 送りあり
      (let1 result (approximate-search db keyword #t)  (disp-search-result result))
      (henkan-okuri-ari db keyword))
     (else
      ;; 送りなし
      (let1 result (approximate-search db keyword #f)  (disp-search-result result))
      (henkan-okuri-nashi db keyword))))
   ((gen-roman->hiragana keyword)
    (henkan-hiragana db keyword))
   (else
    (henkan-non-kanji db keyword))))




