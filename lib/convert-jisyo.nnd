:; #-*- mode: nendo; syntax: scheme -*-;;

(use srfi-1)
(load "./lib/util.nnd")
(load "./lib/roman-lib.nnd")


(define (expand-okuri-nashi-entry key value)
  (let1 roman-list (gen-hiragana->roman-list key)
    (append
     (map
      (lambda (x)
        (cons x (+ "C" key)))
      roman-list)
     (list (cons key value)))))


(define (expand-okuri-ari-entry-internal key okuri value)
  (let1 roman-list (gen-hiragana->roman-list key)
    (append
     (map
      (lambda (x)
        (cons (+ x (sekka-upcase okuri)) (+ "C" key okuri)))
      roman-list)
     (list (cons (+ key okuri) value)))))

(define (expand-okuri-ari-entry key okuri value)
  (cond
   ((eq? "t" okuri)
    (append (expand-okuri-ari-entry-internal key okuri                value)
            (expand-okuri-ari-entry-internal key (sekka-upcase "@")   value)))
   (else
    (expand-okuri-ari-entry-internal key okuri value))))


(define (convert-skk-jisyo-f f)
  (define total   0)
  (define current 0)

  (define (display-progress line)
    (set! current (+ current 1))
    (when (= 0 (% current 10000))
      (STDERR.printf "  %7d/%7d (%3.3f％)\n" current total (/ current (total.to_f)))))

  (define (gen-sekka-entries line)
    (display-progress line)

    (let* ((line   (line.sub #/\/$/ ""))
           (fields (split-dict-line line)))
      (cond
       ((rxmatch #/^\;/ line)
        ;; コメント行
        #f)
       ((not fields)
        ;; フォーマットエラー
        #f)
       ((or (is-hiragana (first fields))
            (rxmatch #/^([>あ-ん]+)$/ (first fields)))
        ;; 送り仮名なしデータ
        (expand-okuri-nashi-entry (first fields) (second fields)))
       ((rxmatch #/^([>あ-ん]+)([a-z])$/ (first fields))
        => (lambda (m)
             ;; 送り仮名ありデータ
             (expand-okuri-ari-entry (rxmatch-substring m 1)
                                     (rxmatch-substring m 2)
                                     (second fields))))
       ((rxmatch #/[亜-瑤]+/ (first fields))
        ;; 漢字が1文字でも含まれている
        #f)
       (else
        (list (cons (first fields) (second fields)))))))

  (let* ((lines
          (map
           (lambda (line)
             (line.chomp))
           (f.readlines.to_list)))
         (_ (set! total (length lines)))
         (entry-list
          (filter
           (lambda (x) x)
           (map gen-sekka-entries lines))))
    (map
     (lambda (entry)
       (sprintf "%s %s" (car entry) (cdr entry)))
     (apply append! entry-list))))



